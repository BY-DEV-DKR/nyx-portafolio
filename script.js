const translations = {
    es: {
        "hero.title": "NYX",
        "hero.subtitle": "Desarrollador de Sistemas Avanzados",
        "hero.lead": "Diseño sistemas complejos, optimizados y escalables para comunidades digitales.",
        "skills.title": "HABILIDADES PRINCIPALES",
        "experience.title": "EXPERIENCIA",
        "experience.text": "Desarrollo proyectos desde cero con visión a largo plazo, priorizando rendimiento, escalabilidad y control total del sistema.",
        "why.title": "¿POR QUÉ NYX?",
        "why.li1": "No entrego configs, entrego sistemas",
        "why.li2": "Optimización real, no placebo",
        "why.li3": "Diseño limpio y mantenible",
        "why.li4": "Visión profesional y técnica",
        "services.title": "SERVICIOS",
        "services.card1.title": "Desarrollo Web",
        "services.card1.desc": "Páginas web modernas, interfaces intuitivas y sistemas de gestión personalizados.",
        "services.card2.title": "Servidores de Discord",
        "services.card2.desc": "Desarrollo de servidores de Discord personalizados con bots, tickets, reseñas automáticas y moderación estructurada.",
        "services.card3.title": "Bots de Discord",
        "services.card3.desc": "Desarrollo de bots personalizados para servidores de Discord con funcionalidades y sistemas avanzados.",
        "services.card4.title": "Servidores de Minecraft",
        "services.card4.desc": "Desarrollo de servidores de Minecraft personalizados con economías, rangos, dungeons y optimización avanzada.",
        "services.card5.title": "Soporte 24/7 Post-Venta",
        "services.card5.desc": "Soporte continuo y mantenimiento para asegurar el rendimiento y la estabilidad del sistema.",
        "footer.contact": "(Discord) Contacto:",
        "skills.card1.title": "Arquitectura de Sistemas",
        "skills.card1.desc": "Diseño de sistemas completos, automatización de procesos y optimización avanzada.",
        "skills.card2.title": "Minecraft Avanzado",
        "skills.card2.desc": "Servidores custom, economías, rangos, dungeons, menús avanzados y optimización de TPS.",
        "skills.card3.title": "Sistemas para Discord",
        "skills.card3.desc": "Bots personalizados, tickets, reseñas automáticas, anuncios y moderación estructurada.",
        "skills.card4.title": "Web y UI",
        "skills.card4.desc": "Webs oscuras, sistemas de login, UX moderno y diseño orientado a comunidades."
    },
    en: {
        "hero.title": "NYX",
        "hero.subtitle": "Advanced Systems Developer",
        "hero.lead": "I design complex, optimized and scalable systems for digital communities.",
        "skills.title": "CORE SKILLS",
        "experience.title": "EXPERIENCE",
        "experience.text": "I build projects from scratch with long-term vision, prioritizing performance, scalability and total system control.",
        "why.title": "WHY NYX",
        "why.li1": "I deliver systems, not configs",
        "why.li2": "Real optimization, not placebo",
        "why.li3": "Clean, maintainable design",
        "why.li4": "Professional technical vision",
        "services.title": "SERVICES",
        "services.card1.title": "Web Development",
        "services.card1.desc": "Modern websites, intuitive interfaces and custom management systems.",
        "services.card2.title": "Discord Servers",
        "services.card2.desc": "Custom Discord server development with bots, tickets, automated reviews and structured moderation.",
        "services.card3.title": "Discord Bots",
        "services.card3.desc": "Custom bot development for Discord servers with advanced functionalities and systems.",
        "services.card4.title": "Minecraft Servers",
        "services.card4.desc": "Custom Minecraft server development with economies, ranks, dungeons and advanced optimization.",
        "services.card5.title": "24/7 Post-Sale Support",
        "services.card5.desc": "Ongoing support and maintenance to ensure system performance and stability.",
        "footer.contact": "(Discord) Contact:",
        "skills.card1.title": "System Architecture",
        "skills.card1.desc": "Design of end-to-end systems, process automation and advanced optimization.",
        "skills.card2.title": "Minecraft Advanced",
        "skills.card2.desc": "Custom servers, economies, ranks, dungeons, advanced menus and TPS optimization.",
        "skills.card3.title": "Discord Systems",
        "skills.card3.desc": "Custom bots, tickets, automated reviews, announcements and structured moderation.",
        "skills.card4.title": "Web & UI",
        "skills.card4.desc": "Dark websites, login systems, modern UX and community-oriented design."
    }
};

translations.es["hero.cta"] = "Ver Proyectos";
translations.en["hero.cta"] = "View Projects";
translations.es["copy.button"] = "Copiar";
translations.en["copy.button"] = "Copy";
translations.es["copy.copied"] = "¡Copiado al portapapeles!";
translations.en["copy.copied"] = "Copied to clipboard!";
translations.es["details.button"] = "Ver Detalles";
translations.en["details.button"] = "View Details";
translations.es["discord.button"] = "Discord";
translations.en["discord.button"] = "Discord";

translations.es["projects.title"] = "PROJECTS";
translations.es["projects.p1.title"] = "Nyx Core";
translations.es["projects.p1.desc"] = "Sistema modular para servidores y automatización de procesos.";
translations.es["projects.p2.title"] = "Dark Portal";
translations.es["projects.p2.desc"] = "Web UI oscura con autenticación y panel de administración.";
translations.es["projects.p3.title"] = "Nyxary";
translations.es["projects.p3.desc"] = "Comunidad dedicada a la venta de servicios y productos digitales.";
translations.es["projects.p4.title"] = "Exilion Network";
translations.es["projects.p4.desc"] = "Servidor de Minecraft con economías, minijuegos y eventos personalizados.";

translations.en["projects.title"] = "PROJECTS";
translations.en["projects.p1.title"] = "Nyx Core";
translations.en["projects.p1.desc"] = "Modular system for servers and process automation.";
translations.en["projects.p2.title"] = "Dark Portal";
translations.en["projects.p2.desc"] = "Dark UI web with authentication and admin panel.";
translations.en["projects.p3.title"] = "Nyxary";
translations.en["projects.p3.desc"] = "Community dedicated to selling digital services and products.";
translations.en["projects.p4.title"] = "Exilion Network";
translations.en["projects.p4.desc"] = "Minecraft server with economies, minigames and custom events.";

translations.es["stats.title"] = "IMPACTO";
translations.es["stats.label1"] = "Proyectos Completados";
translations.es["stats.label2"] = "Usuarios Activos";
translations.es["stats.label3"] = "% Tasa de Satisfacción";
translations.es["stats.label4"] = "Años de Experiencia";

translations.en["stats.title"] = "IMPACT";
translations.en["stats.label1"] = "Projects Completed";
translations.en["stats.label2"] = "Active Users";
translations.en["stats.label3"] = "% Satisfaction Rate";
translations.en["stats.label4"] = "Years of Experience";
function initProjects() {
    const filterButtons = document.querySelectorAll('.filter-btn');
    const cards = document.querySelectorAll('.project-card');
    const modal = document.querySelector('.modal');
    const modalTitle = document.querySelector('.modal-title');
    const modalBody = document.querySelector('.modal-body');
    const modalClose = document.querySelector('.modal-close');

    filterButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            filterButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const f = btn.dataset.filter;
            cards.forEach(c => {
                const tags = c.dataset.tags.split(',');
                if (f === 'all' || tags.includes(f)) c.style.display = '';
                else c.style.display = 'none';
            });
        });
    });

    document.querySelectorAll('.btn-details').forEach((btn, idx) => {
        btn.addEventListener('click', (e) => {
            const card = e.target.closest('.project-card');
            const title = card.querySelector('h4').textContent;
            const desc = card.querySelector('p').textContent;
            modalTitle.textContent = title;
            modalBody.textContent = desc + '\n\nMás información disponible bajo petición.';
            modal.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden';
        });
    });

    modalClose.addEventListener('click', () => {
        modal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
    });

    modal.addEventListener('click', (e) => { if (e.target === modal) { modal.setAttribute('aria-hidden', 'true'); document.body.style.overflow = ''; } });
}

function applyTranslations(lang) {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const txt = translations[lang] && translations[lang][key];
        if (txt) el.textContent = txt;
    });
    document.documentElement.lang = lang;
}

function setActiveLangButton(lang) {
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    const saved = localStorage.getItem('nyx_lang');
    const browserLang = (navigator.language || navigator.userLanguage || 'es').startsWith('en') ? 'en' : 'es';
    const initial = saved || browserLang;

    applyTranslations(initial);
    setActiveLangButton(initial);

    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const lang = btn.dataset.lang;
            applyTranslations(lang);
            setActiveLangButton(lang);
            localStorage.setItem('nyx_lang', lang);
        });
    });

    const elements = document.querySelectorAll('.card, .section h3, .text, .why li');

    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.style.opacity = 1;
                entry.target.style.transform = 'translateY(0)';
            }
        });
    }, { threshold: 0.1 });

    elements.forEach(el => {
        el.style.opacity = 0;
        el.style.transform = 'translateY(30px)';
        el.style.transition = 'all 0.6s ease';
        observer.observe(el);
    });

    initProjects();
    initStatsAnimation();

    const copyBtn = document.getElementById('copy-discord');
    const discordTag = document.getElementById('discord-tag');
    function showToast(msg) {
        let t = document.querySelector('.toast');
        if (!t) {
            t = document.createElement('div');
            t.className = 'toast';
            document.body.appendChild(t);
        }
        t.textContent = msg;
        t.style.opacity = '1';
        t.style.transform = 'translateY(0)';
        setTimeout(() => { t.style.opacity = '0'; t.style.transform = 'translateY(10px)'; }, 1800);
    }

    if (copyBtn && discordTag) {
        copyBtn.addEventListener('click', () => {
            const text = discordTag.textContent.trim();
            navigator.clipboard?.writeText(text).then(() => {
                const curLang = document.documentElement.lang || 'es';
                const msg = translations[curLang]["copy.copied"] || 'Copied!';
                showToast(msg);
            }).catch(() => { alert('Copy failed'); });
        });
    }

    initHeroCanvas();

    initLazyIframes();
});

function initHeroCanvas() {
    const canvas = document.getElementById('hero-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let w = canvas.width = canvas.clientWidth;
    let h = canvas.height = canvas.clientHeight;
    const particles = [];
    let PARTICLE_COUNT = Math.min(120, Math.floor((w * h) / 60000));
    let mouse = { x: w / 2, y: h / 2 };

    function rand(min, max) { return Math.random() * (max - min) + min; }

    function createParticles() {
        particles.length = 0;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({
                x: rand(0, w), y: rand(0, h),
                r: rand(0.6, 2.4),
                vx: rand(-0.25, 0.25), vy: rand(-0.2, 0.2),
                phase: rand(0, Math.PI * 2)
            });
        }
    }

    function resize() {
        w = canvas.width = canvas.clientWidth;
        h = canvas.height = canvas.clientHeight;
        PARTICLE_COUNT = Math.min(140, Math.floor((w * h) / 50000));
        createParticles();
    }

    window.addEventListener('resize', () => { resize(); });
    canvas.addEventListener('mousemove', (e) => { const r = canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; });
    canvas.addEventListener('mouseleave', () => { mouse.x = w / 2; mouse.y = h / 2; });

    function draw() {
        ctx.clearRect(0, 0, w, h);
        const g = ctx.createLinearGradient(0, 0, w, h);
        g.addColorStop(0, 'rgba(6,6,6,1)');
        g.addColorStop(1, 'rgba(12,6,6,1)');
        ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);

        ctx.save();
        ctx.globalAlpha = 0.035;
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        const gridSize = Math.max(60, Math.floor(w / 12));
        const t = Date.now() * 0.0008;
        const offsetX = (t * 40) % gridSize;
        const offsetY = (t * 20) % gridSize;
        ctx.lineWidth = 1;
        for (let x = -gridSize; x < w + gridSize; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x + offsetX, -10); ctx.lineTo(x + offsetX, h + 10); ctx.stroke();
        }
        for (let y = -gridSize; y < h + gridSize; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(-10, y + offsetY); ctx.lineTo(w + 10, y + offsetY); ctx.stroke();
        }
        ctx.restore();

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.phase += 0.002 + (i % 3) * 0.0005;
            const wobbleX = Math.sin(p.phase * 1.2) * 6;
            const wobbleY = Math.cos(p.phase * 0.9) * 4;

            const dx = mouse.x - p.x;
            const dy = mouse.y - p.y;
            const dist = Math.hypot(dx, dy) + 0.01;
            const force = Math.min(0.9, 6000 / (dist * dist));
            p.vx += (dx / dist) * force * 0.0002;
            p.vy += (dy / dist) * force * 0.0002;

            p.x += p.vx + wobbleX * 0.02;
            p.y += p.vy + wobbleY * 0.02;

            p.vx *= 0.94; p.vy *= 0.94;

            if (p.x < -20) p.x = w + 20; if (p.x > w + 20) p.x = -20;
            if (p.y < -20) p.y = h + 20; if (p.y > h + 20) p.y = -20;

            const distToMouse = Math.hypot(p.x - mouse.x, p.y - mouse.y);
            const alpha = Math.max(0.06, 1 - distToMouse / (w * 0.6));
            ctx.beginPath();
            ctx.fillStyle = `rgba(255,40,40,${alpha * 0.9})`;
            ctx.arc(p.x, p.y, p.r + 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath(); ctx.fillStyle = `rgba(255,120,120,${Math.min(0.9, alpha * 1.2)})`; ctx.arc(p.x, p.y, p.r * 0.5, 0, Math.PI * 2); ctx.fill();
        }

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < particles.length; i++) {
            const a = particles[i];
            for (let j = i + 1; j < particles.length; j++) {
                const b = particles[j];
                const dx = a.x - b.x; const dy = a.y - b.y;
                const dsq = dx * dx + dy * dy;
                const maxDist = 140 * (Math.min(1.5, Math.max(0.6, (w / 1400))));
                if (dsq < maxDist * maxDist) {
                    const d = Math.sqrt(dsq);
                    const lineAlpha = Math.max(0, 0.18 * (1 - d / maxDist));
                    ctx.strokeStyle = `rgba(179,0,0,${lineAlpha})`;
                    ctx.lineWidth = 1 * (1 - d / (maxDist * 1.1));
                    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
                }
            }
        }
        ctx.restore();

        const grd = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.max(w, h) * 0.3, w * 0.5, h * 0.5, Math.max(w, h) * 0.95);
        grd.addColorStop(0, 'rgba(0,0,0,0)');
        grd.addColorStop(1, 'rgba(0,0,0,0.45)');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, w, h);

        requestAnimationFrame(draw);
    }

    createParticles();
    draw();
}

function initLazyIframes() {
    const iframes = document.querySelectorAll('iframe[data-src]');
    if (!iframes.length) return;
    const obs = new IntersectionObserver((entries, o) => {
        entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            const iframe = entry.target;
            const src = iframe.getAttribute('data-src');
            if (src) iframe.src = src;
            iframe.removeAttribute('data-src');
            o.unobserve(iframe);
        });
    }, { rootMargin: '200px 0px' });

    iframes.forEach(f => {
        obs.observe(f);
    });
}

function initStatsAnimation() {
    const statValues = document.querySelectorAll('.stat-value');
    if (!statValues.length) return;

    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            const element = entry.target;
            const target = parseInt(element.dataset.value);
            animateCounter(element, target);
            observer.unobserve(element);
        });
    }, { threshold: 0.5 });

    statValues.forEach(stat => observer.observe(stat));
}

function animateCounter(element, target) {
    let current = 0;
    const increment = Math.ceil(target / 60);
    const duration = 60;
    let elapsed = 0;

    const interval = setInterval(() => {
        elapsed++;
        current = Math.min(current + increment, target);
        element.textContent = current;

        if (current >= target || elapsed >= duration) {
            element.textContent = target;
            clearInterval(interval);
        }
    }, 16);
}
